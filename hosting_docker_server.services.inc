<?php
/**
 * @file
 * Hosting service classes for the Hosting web server module.osting service classes for the Hosting web server module.
 */

module_load_include('service.inc', 'hosting_web_server');
module_load_include('service.inc', 'hosting_db_server');

class hostingService_http_apache_docker extends hostingService_http_apache {
  public $type = 'apache_docker';
  public $name = 'Apache on Docker';

  /**
   * Currently used to tell hosting_docker_server_has_docker_services() that this
   * is a docker service. Eventually replace this with an interface, like in
   * Provision 4.x.
   *
   * @var bool
   */
  static $DOCKER_SERVICE = TRUE;

  // It does but we don't let the user edit it.
  public $has_restart_cmd = FALSE;
  
  function default_port()
  {
    return 0;
  }

  function form(&$form)
  {
    parent::form($form); // TODO: Change the autogenerated stub
    $form['port']['#description'] = t('Internally, the Apache Docker container always listens on port 80. Enter the port on the host that will be mapped to port 80 in the container. Set to "0" to let docker assign a random available port. (Recommended once we have load balancers.)');

    $form['docker_php_version'] = array(
      '#title' => t('PHP Version'),
      '#description' => t('Select the version of PHP to run on this server. More versions coming soon.'),
      '#type' => 'radios',
      '#options' => array(
        '5.5' => '5.5 <small><em>on Ubuntu 14</em></small>',
        '7.0' => '7.0 <small><em>on Ubuntu 16</em></small>',
      ),
      '#default_value' => $this->docker_php_version,
    );
  }

  /**
   * Load information into the service class.
   */
  function load() {
    parent::load();
    if ($this->server->name) {
      $this->setValues(array(
        'docker_php_version' => variable_get("hosting_docker_server_{$this->server->name}_php_version", '5.5'),
      ));
    }
  }

  /**
   * Load information into the service class.
   */
  function update() {
    parent::update();
    variable_set("hosting_docker_server_{$this->server->name}_php_version", $this->docker_php_version);
  }

  function validate(&$node, &$form, &$form_state)
  {
    // Don't run parent, we allow empty port.
    // parent::validate($node, $form, $form_state); // TODO: Change the autogenerated stub
  }
  
}
class hostingService_db_mysql_docker extends hostingService_db_mysql {
  public $type = 'mysql_docker';
  public $name = 'MySQL on Docker';
  public $has_restart_cmd = FALSE;

  static $DOCKER_SERVICE = TRUE;

  function default_port()
  {
    return 0;
  }
  
  function form(&$form)
  {
    parent::form($form);
    $form['port']['#description'] = t('Internally, the MySQL container always listens on port 3306. Enter the port on the host that will be mapped to port 3306 in the container. Set to "0" to not expose a port at all. (Recommended, unless you need external access.)');
    
    // Form username to root.
    $form['db_user'] = array(
      '#type' => 'value',
      '#value' => 'root',
    );
    
    // Force username to root.
    $form['db_user_item'] = array(
      '#type' => 'item',
      '#title' => t('Username'),
      '#markup' => 'root',
      '#description' => t('Database container user is always root.'),
    );
    
    // Force password to random.
    $form['db_passwd'] = array(
      '#type' => 'value',
      '#value' => $this->db_passwd? $this->db_passwd: user_password(32),
    );
  
    $form['db_pass_item'] = array(
      '#type' => 'item',
      '#title' => t('Password'),
      '#markup' => 'Automatically generated.',
      '#description' => t('Database password is generated.'),
    );
  }
  
  
  function validate(&$node, &$form, &$form_state)
  {
    // Don't run parent, we allow empty port.
    // parent::validate($node, $form, $form_state); // TODO: Change the autogenerated stub
  }
  
  /**
   * Save context options to the drush alias.
   *
   * Change the hostname to match the container name instead of the server node title.
   *
   * @TODO: Figure out how we could move this to provision.
   *
   * @param $task_type
   * @param $ref_type
   * @param $task
   */
  public function context_options($task_type, $ref_type, &$task) {
    parent::context_options($task_type, $ref_type, $task);
  
    $container_name = preg_replace("/[^A-Za-z0-9_ ]/", '', "server{$this->server->title}_db_1");
    
    // Provide context_options for verification and writing out to an alias
    $task->context_options['master_db'] = 'mysql' . '://' . urlencode($this->db_user) . ':' . urlencode($this->db_passwd) . '@' . $container_name;
  }
}


class hostingService_cache extends hostingService {
  public $service = 'cache';
}

class hostingService_cache_varnish extends hostingService_cache {
  protected $has_port = TRUE;
  public $name = 'Varnish';
  public $type = 'varnish';
  
  
  function default_port() {
    return 80;
  }
}